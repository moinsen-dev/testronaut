{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Testronaut","text":"<p>Testronaut is an AI-assisted testing tool for command-line applications.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>Analyzes CLI applications to understand their command structure</li> <li>Two-phase analysis for complex command hierarchies</li> <li>Robust cycle detection to prevent infinite loops</li> <li>Detailed progress reporting during analysis</li> <li>Generates comprehensive test plans automatically</li> <li>Creates runnable test files based on test plans</li> <li>Verifies test execution against expected results</li> <li>Generates detailed reports of test outcomes</li> </ul>"},{"location":"#installation","title":"Installation","text":"<pre><code>pip install testronaut\n</code></pre>"},{"location":"#quick-example","title":"Quick Example","text":"<pre><code># Analyze a CLI tool\ntestronaut analyze --tool /path/to/cli-tool\n\n# Generate a test plan\ntestronaut generate --analysis-file analysis.json --output test-plan.json\n\n# Verify the tests\ntestronaut verify --test-plan test-plan.json\n\n# Generate a report\ntestronaut report --verification-results results.json --format html\n</code></pre>"},{"location":"#why-testronaut","title":"Why Testronaut?","text":"<p>Testing command-line applications involves repetitive tasks like understanding command structures, generating test cases, and checking outputs. Testronaut automates this entire workflow, saving time and ensuring comprehensive test coverage.</p>"},{"location":"#license","title":"License","text":"<p>This project is licensed under the MIT License - see the LICENSE file for details.</p>"},{"location":"api/overview/","title":"API Overview","text":"<p>Testronaut provides a comprehensive Python API that can be used programmatically in your applications and workflows. This document provides an overview of the main API components.</p>"},{"location":"api/overview/#core-modules","title":"Core Modules","text":"<p>Testronaut's API is organized into several key modules:</p> <ul> <li>Core: Contains the main business logic components</li> <li>CLI: Command-line interface components</li> <li>Models: Data models for test plans and analysis</li> <li>Utils: Utility functions and helpers</li> </ul>"},{"location":"api/overview/#getting-started","title":"Getting Started","text":"<p>To use Testronaut in your Python code, start by importing the relevant modules:</p> <pre><code>from testronaut.core.analyzer import CLIAnalyzer\nfrom testronaut.core.generator import TestPlanGenerator\nfrom testronaut.core.executor import TestExecutor\nfrom testronaut.core.models.test_plan import TPTestPlan, TPTestCase\n</code></pre>"},{"location":"api/overview/#basic-usage","title":"Basic Usage","text":"<p>Here's a simple example that demonstrates how to use the Testronaut API to analyze a CLI tool and generate a test plan:</p> <pre><code>from testronaut.core.analyzer import CLIAnalyzer\nfrom testronaut.core.generator import TestPlanGenerator\n\n# Analyze a CLI tool\nanalyzer = CLIAnalyzer(tool_path=\"/usr/bin/git\")\nanalysis_result = analyzer.analyze()\n\n# Generate a test plan\ngenerator = TestPlanGenerator(analysis=analysis_result)\ntest_plan = generator.generate()\n\n# Save the test plan to a file\ntest_plan.save(\"git_test_plan.json\")\n\n# Load a test plan from a file\nfrom testronaut.core.models.test_plan import TPTestPlan\nloaded_test_plan = TPTestPlan.load(\"git_test_plan.json\")\n\n# Execute the test plan\nfrom testronaut.core.executor import TestExecutor\nexecutor = TestExecutor(test_plan=loaded_test_plan, tool_path=\"/usr/bin/git\")\nresults = executor.execute()\n\n# Generate a report\nfrom testronaut.core.reporting import ReportGenerator\nreporter = ReportGenerator(results=results)\nreporter.generate_report(format=\"html\", output_path=\"git_test_report.html\")\n</code></pre>"},{"location":"api/overview/#main-components","title":"Main Components","text":""},{"location":"api/overview/#clianalyzer","title":"CLIAnalyzer","text":"<p>The <code>CLIAnalyzer</code> class is responsible for analyzing command-line tools to understand their structure, commands, and options.</p> <pre><code>from testronaut.core.analyzer import CLIAnalyzer\n\nanalyzer = CLIAnalyzer(\n    tool_path=\"/usr/bin/docker\",\n    max_depth=3,\n    skip_subcommands=False,\n    timeout=30\n)\nanalysis = analyzer.analyze()\nanalysis.save(\"docker_analysis.json\")\n</code></pre>"},{"location":"api/overview/#testplangenerator","title":"TestPlanGenerator","text":"<p>The <code>TestPlanGenerator</code> class creates test plans based on CLI analysis results.</p> <pre><code>from testronaut.core.generator import TestPlanGenerator\nfrom testronaut.core.models.cli_tool import CLITool\n\n# Create from an analysis result\ngenerator = TestPlanGenerator(analysis=analysis_result)\n\n# Or directly from a CLI tool model\ncli_tool = CLITool.load(\"docker_analysis.json\")\ngenerator = TestPlanGenerator(cli_tool=cli_tool)\n\n# Generate a test plan\ntest_plan = generator.generate(\n    test_scope=\"comprehensive\",\n    test_cases=10,\n    enhance=True\n)\n</code></pre>"},{"location":"api/overview/#testexecutor","title":"TestExecutor","text":"<p>The <code>TestExecutor</code> class runs test plans against CLI tools.</p> <pre><code>from testronaut.core.executor import TestExecutor\nfrom testronaut.core.models.test_plan import TPTestPlan\n\n# Load a test plan\ntest_plan = TPTestPlan.load(\"docker_test_plan.json\")\n\n# Create an executor\nexecutor = TestExecutor(\n    test_plan=test_plan,\n    tool_path=\"/usr/bin/docker\",\n    use_docker=True,\n    docker_image=\"ubuntu:latest\"\n)\n\n# Execute the tests\nresults = executor.execute()\n</code></pre>"},{"location":"api/overview/#tptestplan-and-tptestcase","title":"TPTestPlan and TPTestCase","text":"<p>The <code>TPTestPlan</code> and <code>TPTestCase</code> classes represent test plans and test cases, respectively.</p> <pre><code>from testronaut.core.models.test_plan import TPTestPlan, TPTestCase, TestStep, TestStepType\n\n# Create a test step\nstep = TestStep(\n    type=TestStepType.COMMAND,\n    command=\"git init\",\n    expected_output=\"Initialized empty Git repository\",\n    expected_exit_code=0\n)\n\n# Create a test case\ntest_case = TPTestCase(\n    name=\"Test Git Init\",\n    description=\"Test the git init command\",\n    steps=[step]\n)\n\n# Create a test plan\ntest_plan = TPTestPlan(\n    name=\"Git Test Plan\",\n    description=\"Test plan for Git\",\n    target=\"git\",\n    test_cases=[test_case]\n)\n\n# Save the test plan\ntest_plan.save(\"git_test_plan.json\")\n</code></pre>"},{"location":"api/overview/#error-handling","title":"Error Handling","text":"<p>Testronaut provides several exception classes for handling errors:</p> <pre><code>from testronaut.core.exceptions import (\n    TestronaughtError,\n    AnalysisError,\n    GenerationError,\n    ExecutionError,\n    ValidationError\n)\n\ntry:\n    analysis = analyzer.analyze()\nexcept AnalysisError as e:\n    print(f\"Analysis failed: {e}\")\n</code></pre>"},{"location":"api/overview/#advanced-usage","title":"Advanced Usage","text":""},{"location":"api/overview/#custom-test-plan-enhancement","title":"Custom Test Plan Enhancement","text":"<p>You can use the AI enhancement capabilities to improve test plans:</p> <pre><code>from testronaut.core.enhancer import TestPlanEnhancer\n\nenhancer = TestPlanEnhancer(\n    provider=\"openai\",\n    model=\"gpt-4\"\n)\n\nenhanced_plan = enhancer.enhance(test_plan)\n</code></pre>"},{"location":"api/overview/#docker-integration","title":"Docker Integration","text":"<p>For isolated test execution, you can use Docker:</p> <pre><code>from testronaut.core.executor import DockerExecutor\n\ndocker_executor = DockerExecutor(\n    test_plan=test_plan,\n    tool_path=\"/usr/bin/npm\",\n    image=\"node:16\",\n    timeout=60\n)\n\nresults = docker_executor.execute()\n</code></pre>"},{"location":"api/overview/#next-steps","title":"Next Steps","text":"<ul> <li>Explore the Core API for detailed information on analyzer and generator classes</li> <li>Check the CLI API to understand how the command-line interface is implemented</li> <li>Review the Models API for details on data structures</li> </ul>"},{"location":"guides/advanced_analysis/","title":"Advanced CLI Analysis Techniques","text":"<p>The Testronaut framework includes sophisticated analysis techniques to handle complex CLI tools with deep command hierarchies. This guide explains two key features: two-phase analysis and cycle detection.</p>"},{"location":"guides/advanced_analysis/#two-phase-analysis","title":"Two-Phase Analysis","text":"<p>The CLI analyzer uses a two-phase approach to analyze complex command-line tools:</p>"},{"location":"guides/advanced_analysis/#phase-1-command-discovery","title":"Phase 1: Command Discovery","text":"<p>In the first phase, the analyzer focuses on building a complete command tree structure without performing detailed analysis:</p> <ol> <li>The analyzer starts by extracting the top-level commands from the main help text</li> <li>For each command, it retrieves the help text and extracts its immediate subcommands</li> <li>This process continues recursively to discover the entire command hierarchy</li> <li>Command relationships (parent-child) are established during this phase</li> <li>The analyzer tracks processed commands to avoid re-analyzing the same command</li> </ol> <p>This approach allows the analyzer to quickly build a comprehensive view of the command structure before diving into detailed analysis.</p>"},{"location":"guides/advanced_analysis/#phase-2-detailed-analysis","title":"Phase 2: Detailed Analysis","text":"<p>Once the command tree is built, the analyzer proceeds to the second phase:</p> <ol> <li>Each command is analyzed individually in a sequential manner</li> <li>The analyzer extracts detailed information such as:</li> <li>Command descriptions</li> <li>Available options (flags)</li> <li>Required and optional arguments</li> <li>Usage examples</li> <li>Syntax patterns</li> <li>The analyzer enriches each command with this detailed information</li> <li>Progress is reported for each command being analyzed</li> </ol> <p>This separation ensures that even complex CLI tools with hundreds of commands can be analyzed efficiently and without encountering infinite loops.</p>"},{"location":"guides/advanced_analysis/#cycle-detection","title":"Cycle Detection","text":"<p>CLI tools often have command structures that can create cycles in the command graph, which can lead to infinite loops during analysis. Testronaut implements robust cycle detection:</p>"},{"location":"guides/advanced_analysis/#types-of-cycles","title":"Types of Cycles","text":"<ol> <li>Self-references: Commands that appear to reference themselves (e.g., \"show\" command having a \"Show\" subcommand)</li> <li>Parent-child cycles: Subcommands that reference their parent commands</li> <li>Deep cycles: Complex relationships where a command eventually references itself through multiple levels</li> </ol>"},{"location":"guides/advanced_analysis/#cycle-detection-approach","title":"Cycle Detection Approach","text":"<p>The analyzer implements cycle detection through:</p> <ol> <li>Command ID tracking: Each command gets a unique identifier</li> <li>Processed command set: A set of command IDs that have already been processed is maintained</li> <li>Cycle detection: Before processing a command, the analyzer checks if it's already in the processed set</li> <li>Warning logs: When a potential cycle is detected, a warning is logged for transparency</li> <li>Cycle breaking: The analyzer skips processing commands that would create cycles</li> </ol>"},{"location":"guides/advanced_analysis/#example","title":"Example","text":"<p>Consider a CLI tool with commands like:</p> <pre><code>tool command subcommand\ntool command subcommand Command\n</code></pre> <p>Without cycle detection, the analyzer might enter an infinite loop when it encounters \"Command\" as both a parent and a child. The cycle detection mechanism identifies this pattern and prevents the loop.</p>"},{"location":"guides/advanced_analysis/#detailed-progress-reporting","title":"Detailed Progress Reporting","text":"<p>To provide transparency during analysis, the analyzer implements detailed progress reporting:</p> <ol> <li>Step-by-step logging: Each phase and step is logged with timestamps</li> <li>Command counting: The total number of commands discovered is reported</li> <li>Progress indicators: Visual indicators show which command is being analyzed</li> <li>Cycle warnings: Warnings are issued when cycles are detected and broken</li> <li>Performance metrics: The time taken for analysis is tracked and reported</li> </ol>"},{"location":"guides/advanced_analysis/#usage-example","title":"Usage Example","text":"<p>To leverage these advanced features:</p> <pre><code>from testronaut.analyzers import StandardAnalyzer\n\n# Initialize the analyzer\nanalyzer = StandardAnalyzer()\n\n# Enable verbose mode for detailed progress reporting\nanalyzer.verbose = True\n\n# Analyze a complex CLI tool\ncli_tool = analyzer.analyze_cli_tool(\"complex-cli\")\n\n# Access the complete command hierarchy\nprint(f\"Discovered {len(cli_tool.commands)} commands\")\n</code></pre>"},{"location":"guides/advanced_analysis/#cli-usage","title":"CLI Usage","text":"<p>From the command line:</p> <pre><code>testronaut analyze tool complex-cli --verbose\n</code></pre> <p>The <code>--verbose</code> flag enables detailed progress reporting, showing each phase of the analysis process.</p>"},{"location":"guides/advanced_analysis/#best-practices","title":"Best Practices","text":"<ul> <li>Use the <code>--verbose</code> flag when analyzing complex CLI tools to monitor progress</li> <li>Check the logs for cycle detection warnings, which might indicate unusual command structures</li> <li>For very complex CLI tools, consider analyzing subsets of commands rather than the entire tool</li> <li>Cache analysis results to avoid repeated analysis of the same tool</li> </ul>"},{"location":"guides/concepts/","title":"Core Concepts","text":"<p>This guide explains the core concepts behind Testronaut and how they work together to generate and execute tests for command-line applications.</p>"},{"location":"guides/concepts/#overview","title":"Overview","text":"<p>Testronaut is an AI-assisted testing tool designed to automate the testing of command-line applications. It reduces the need for manual test case creation by analyzing the structure of CLI applications and generating comprehensive test plans.</p>"},{"location":"guides/concepts/#key-components","title":"Key Components","text":""},{"location":"guides/concepts/#cli-analyzer","title":"CLI Analyzer","text":"<p>The CLI Analyzer examines command-line applications to understand:</p> <ul> <li>Available commands and subcommands</li> <li>Command options and arguments</li> <li>Help text and usage patterns</li> <li>Command relationships and hierarchies</li> </ul> <p>The analyzer uses this information to build a detailed model of the CLI application that serves as input for the test generator.</p>"},{"location":"guides/concepts/#test-plan-generator","title":"Test Plan Generator","text":"<p>The Test Plan Generator creates structured test plans based on the CLI analyzer's output. A test plan consists of:</p> <ul> <li>Test Cases: Individual scenarios to test specific commands and options</li> <li>Test Steps: Detailed steps within each test case</li> <li>Expected Results: What success looks like for each test</li> </ul> <p>The generator uses AI to identify meaningful test scenarios, edge cases, and command combinations.</p>"},{"location":"guides/concepts/#test-executor","title":"Test Executor","text":"<p>The Test Executor runs the generated test plans against the target CLI application. It:</p> <ul> <li>Executes commands in isolated environments (using Docker)</li> <li>Captures command output and exit codes</li> <li>Compares actual results with expected results</li> <li>Records test outcomes and evidence</li> </ul>"},{"location":"guides/concepts/#result-verifier","title":"Result Verifier","text":"<p>The Result Verifier analyzes test execution results to determine test success or failure. It uses AI to:</p> <ul> <li>Interpret command output semantically</li> <li>Identify meaningful failures vs. superficial differences</li> <li>Provide detailed explanations for failed tests</li> <li>Suggest improvements for test plans</li> </ul>"},{"location":"guides/concepts/#key-concepts","title":"Key Concepts","text":""},{"location":"guides/concepts/#test-plans","title":"Test Plans","text":"<p>A <code>TPTestPlan</code> is the central structure in Testronaut. It contains:</p> <ul> <li>Metadata about the test target</li> <li>A collection of test cases</li> <li>Configuration for test execution</li> </ul>"},{"location":"guides/concepts/#test-cases","title":"Test Cases","text":"<p>A <code>TPTestCase</code> represents a single test scenario. It contains:</p> <ul> <li>A descriptive name and purpose</li> <li>Test steps to execute</li> <li>Expected results</li> <li>Status information</li> </ul>"},{"location":"guides/concepts/#command-analysis","title":"Command Analysis","text":"<p>Command analysis creates a structured representation of:</p> <ul> <li>Command hierarchy</li> <li>Command options and arguments</li> <li>Expected behavior and output</li> </ul>"},{"location":"guides/concepts/#ai-integration","title":"AI Integration","text":"<p>Testronaut integrates with LLMs to:</p> <ul> <li>Generate meaningful test cases</li> <li>Verify test results semantically</li> <li>Improve test plans over time</li> </ul>"},{"location":"guides/concepts/#workflow","title":"Workflow","text":"<ol> <li>Analyze: Testronaut analyzes the structure of a CLI application</li> <li>Generate: AI creates a comprehensive test plan</li> <li>Execute: Tests run in isolated environments</li> <li>Verify: Results are semantically analyzed</li> <li>Report: Detailed reports are generated</li> </ol>"},{"location":"guides/concepts/#next-steps","title":"Next Steps","text":"<ul> <li>Follow the Quick Start Guide to see Testronaut in action</li> <li>Explore the CLI Reference for detailed command information</li> <li>Learn about Configuration options</li> </ul>"},{"location":"guides/installation/","title":"Installation Guide","text":"<p>Testronaut is a Python package that can be installed using pip or other package managers.</p>"},{"location":"guides/installation/#requirements","title":"Requirements","text":"<ul> <li>Python 3.10 or higher</li> <li>pip or another Python package manager</li> </ul>"},{"location":"guides/installation/#installation-methods","title":"Installation Methods","text":""},{"location":"guides/installation/#using-pip","title":"Using pip","text":"<p>The simplest way to install Testronaut is via pip:</p> <pre><code>pip install testronaut\n</code></pre>"},{"location":"guides/installation/#using-uv-recommended","title":"Using uv (Recommended)","text":"<p>For faster installation, you can use uv:</p> <pre><code>uv pip install testronaut\n</code></pre>"},{"location":"guides/installation/#development-installation","title":"Development Installation","text":"<p>If you want to contribute to Testronaut or need the latest features, you can install directly from GitHub:</p> <pre><code>git clone https://github.com/yourusername/testronaut.git\ncd testronaut\npip install -e \".[dev]\"\n</code></pre>"},{"location":"guides/installation/#verifying-installation","title":"Verifying Installation","text":"<p>After installation, you can verify that Testronaut was installed correctly by running:</p> <pre><code>testronaut --version\n</code></pre> <p>This should display the version number of the installed package.</p>"},{"location":"guides/installation/#updating-testronaut","title":"Updating Testronaut","text":"<p>To update Testronaut to the latest version:</p> <pre><code>pip install --upgrade testronaut\n</code></pre>"},{"location":"guides/installation/#dependencies","title":"Dependencies","text":"<p>Testronaut depends on the following key packages:</p> <ul> <li>typer: For building the command-line interface</li> <li>rich: For enhanced terminal output</li> <li>pydantic: For data validation and settings management</li> </ul> <p>These dependencies will be automatically installed when you install Testronaut.</p>"},{"location":"guides/installation/#troubleshooting","title":"Troubleshooting","text":"<p>If you encounter issues during installation:</p> <ol> <li>Make sure you're using Python 3.10 or higher: <code>python --version</code></li> <li>Ensure pip is up to date: <code>pip install --upgrade pip</code></li> <li>Check for any error messages in the installation output</li> <li>Try installing with the verbose flag: <code>pip install -v testronaut</code></li> </ol> <p>If problems persist, please open an issue on the GitHub repository.</p>"},{"location":"guides/llm_enhanced_analysis/","title":"LLM-Enhanced CLI Analysis","text":"<p>The Testronaut framework includes an LLM-enhanced analyzer that uses large language models to provide deeper insights into CLI tools and commands. This guide covers how to use the enhanced analyzer and the benefits it provides over the standard analyzer.</p>"},{"location":"guides/llm_enhanced_analysis/#overview","title":"Overview","text":"<p>The LLM-enhanced analyzer extends the standard CLI analyzer by adding semantic analysis and relationship detection using large language models. This provides richer information about:</p> <ul> <li>Command purposes and descriptions</li> <li>Semantic relationships between commands</li> <li>Usage patterns and workflows</li> <li>Risk levels and common use cases</li> <li>Improved examples</li> </ul>"},{"location":"guides/llm_enhanced_analysis/#usage","title":"Usage","text":""},{"location":"guides/llm_enhanced_analysis/#basic-usage","title":"Basic Usage","text":"<p>To use the LLM-enhanced analyzer:</p> <pre><code>from testronaut.analyzers import LLMEnhancedAnalyzer\n\n# Initialize the analyzer\nanalyzer = LLMEnhancedAnalyzer()\n\n# Analyze a CLI tool\ncli_tool = analyzer.analyze_cli_tool(\"git\")\n\n# Access commands, options, and arguments\nfor command in cli_tool.commands:\n    print(f\"Command: {command.name}\")\n    print(f\"Description: {command.description}\")\n</code></pre>"},{"location":"guides/llm_enhanced_analysis/#accessing-semantic-analysis","title":"Accessing Semantic Analysis","text":"<p>The LLM-enhanced analyzer adds semantic information to commands:</p> <pre><code>from testronaut.models.cli_tool import get_semantic_analysis\n\n# Analyze a CLI tool\ncli_tool = analyzer.analyze_cli_tool(\"git\")\n\n# For a specific command\ncommand = cli_tool.commands[0]\nsemantic = get_semantic_analysis(command)\n\nif semantic:\n    print(f\"Primary function: {semantic.primary_function}\")\n    print(f\"Risk level: {semantic.risk_level}\")\n    print(f\"Common use cases:\")\n    for use_case in semantic.common_use_cases:\n        print(f\"  - {use_case}\")\n</code></pre>"},{"location":"guides/llm_enhanced_analysis/#accessing-command-relationships","title":"Accessing Command Relationships","text":"<p>The analyzer also detects relationships between commands:</p> <pre><code>from testronaut.models.cli_tool import get_relationship_analysis\n\n# Analyze a CLI tool\ncli_tool = analyzer.analyze_cli_tool(\"git\")\n\n# Get relationship analysis\nrelationships = get_relationship_analysis(cli_tool)\n\nif relationships:\n    # Parent-child relationships (e.g., command and subcommands)\n    print(\"Command hierarchies:\")\n    for rel in relationships.parent_child:\n        print(f\"  {rel.parent} -&gt; {rel.child}\")\n\n    # Common workflows\n    print(\"Common workflows:\")\n    for workflow in relationships.workflows:\n        print(f\"  {workflow.name}: {' -&gt; '.join(workflow.steps)}\")\n</code></pre>"},{"location":"guides/llm_enhanced_analysis/#configuration","title":"Configuration","text":"<p>The LLM-enhanced analyzer uses your configured LLM service. Make sure you have properly configured the LLM service in your <code>config.toml</code> file:</p> <pre><code>[llm]\nprovider = \"openai\"  # or \"anthropic\", \"mock\", etc.\nmodel = \"gpt-4\"      # or appropriate model for your provider\n\n[llm.openai]\napi_key = \"your-api-key\"\n</code></pre>"},{"location":"guides/llm_enhanced_analysis/#benefits-of-llm-enhancement","title":"Benefits of LLM Enhancement","text":"<p>Compared to the standard analyzer, the LLM-enhanced analyzer provides:</p> <ol> <li> <p>More accurate command descriptions: The LLM can provide clear, concise descriptions even when the CLI help text is minimal or unclear.</p> </li> <li> <p>Semantic understanding: The analyzer understands what commands do, not just their syntax.</p> </li> <li> <p>Relationship detection: The analyzer can identify parent-child relationships and common workflows.</p> </li> <li> <p>Risk assessment: Each command is assessed for its risk level, helping identify potentially destructive commands.</p> </li> <li> <p>Use case identification: The analyzer identifies common use cases for each command.</p> </li> <li> <p>Better examples: When native examples are missing, the LLM can generate realistic examples.</p> </li> </ol>"},{"location":"guides/llm_enhanced_analysis/#example-script","title":"Example Script","text":"<p>Check out the <code>examples/llm_enhanced_analysis.py</code> script for a complete example of using the LLM-enhanced analyzer:</p> <pre><code>python examples/llm_enhanced_analysis.py git ./analysis_results\n</code></pre> <p>This will analyze the <code>git</code> CLI tool and save the results to the <code>analysis_results</code> directory.</p>"},{"location":"guides/llm_enhanced_analysis/#limitations","title":"Limitations","text":"<ul> <li>The LLM-enhanced analyzer requires internet connectivity to access LLM services.</li> <li>Analysis with LLM enhancement is slower than the standard analyzer.</li> <li>The quality of the enhancement depends on the quality of the LLM and the prompts used.</li> <li>There may be rate limiting or cost considerations depending on your LLM provider.</li> </ul>"},{"location":"guides/llm_enhanced_analysis/#best-practices","title":"Best Practices","text":"<ul> <li>Use the standard analyzer for quick analysis during development.</li> <li>Use the LLM-enhanced analyzer for final analysis or when generating comprehensive test plans.</li> <li>Cache analysis results to avoid repeated API calls to LLM services.</li> <li>Review and validate LLM-generated insights, especially for critical commands.</li> </ul>"},{"location":"guides/quickstart/","title":"Quick Start Guide","text":"<p>This guide will help you get started with Testronaut by walking through a basic workflow for testing a command-line application.</p>"},{"location":"guides/quickstart/#prerequisites","title":"Prerequisites","text":"<ul> <li>Testronaut installed</li> <li>A command-line application you want to test</li> </ul>"},{"location":"guides/quickstart/#basic-workflow","title":"Basic Workflow","text":""},{"location":"guides/quickstart/#1-analyze-your-cli-tool","title":"1. Analyze Your CLI Tool","text":"<p>First, analyze your command-line tool to understand its structure:</p> <pre><code>testronaut analyze --tool /path/to/your/cli-tool\n</code></pre> <p>This will generate an analysis file (default: <code>analysis.json</code>) containing information about the tool's commands, options, and arguments.</p>"},{"location":"guides/quickstart/#2-generate-a-test-plan","title":"2. Generate a Test Plan","text":"<p>Next, generate a test plan based on the analysis:</p> <pre><code>testronaut generate --analysis-file analysis.json --output test-plan.json\n</code></pre> <p>The test plan will contain test cases for each command detected in your CLI tool.</p>"},{"location":"guides/quickstart/#3-verify-the-tests","title":"3. Verify the Tests","text":"<p>Run the tests defined in your test plan:</p> <pre><code>testronaut verify --test-plan test-plan.json\n</code></pre> <p>This will execute each test case and record the results.</p>"},{"location":"guides/quickstart/#4-generate-a-report","title":"4. Generate a Report","text":"<p>Finally, generate a report of the test results:</p> <pre><code>testronaut report --verification-results verification-results.json --format html\n</code></pre> <p>This will create a detailed report showing which tests passed and failed.</p>"},{"location":"guides/quickstart/#complete-example","title":"Complete Example","text":"<p>Here's a complete example testing a hypothetical CLI tool called <code>demo-cli</code>:</p> <pre><code># Analyze the CLI tool\ntestronaut analyze --tool /usr/local/bin/demo-cli\n\n# Generate a test plan\ntestronaut generate --analysis-file analysis.json --output test-plan.json\n\n# Optionally, review and modify the test plan\n# edit test-plan.json\n\n# Verify the tests\ntestronaut verify --test-plan test-plan.json\n\n# Generate an HTML report\ntestronaut report --verification-results verification-results.json --format html\n</code></pre>"},{"location":"guides/quickstart/#next-steps","title":"Next Steps","text":"<ul> <li>Learn about core concepts to understand how Testronaut works</li> <li>Explore the CLI reference for detailed command options</li> <li>See how to customize test plans for more complex testing scenarios</li> </ul>"},{"location":"reference/cli/","title":"CLI Reference","text":"<p>Testronaut provides a comprehensive command-line interface for analyzing CLI tools, generating test plans, and executing tests.</p>"},{"location":"reference/cli/#global-options","title":"Global Options","text":"Option Description <code>--help</code> Show the help message and exit <code>--version</code> Show the version and exit <code>--verbose</code> Enable verbose output <code>--quiet</code> Suppress non-error output <code>--log-level [LEVEL]</code> Set the log level (DEBUG, INFO, WARNING, ERROR, CRITICAL)"},{"location":"reference/cli/#commands","title":"Commands","text":""},{"location":"reference/cli/#analyze","title":"analyze","text":"<p>Analyze a CLI tool and create an analysis file.</p> <pre><code>testronaut analyze [OPTIONS] TOOL_PATH\n</code></pre>"},{"location":"reference/cli/#options","title":"Options","text":"Option Description <code>--output-dir PATH</code> Directory to store the analysis output [default: current directory] <code>--output-file TEXT</code> Name of the output file [default: analysis.json] <code>--skip-subcommands</code> Skip analyzing subcommands <code>--max-depth INTEGER</code> Maximum depth for subcommand analysis [default: 3] <code>--help</code> Show the command help message and exit"},{"location":"reference/cli/#examples","title":"Examples","text":"<pre><code># Analyze a CLI tool\ntestronaut analyze /usr/bin/docker\n\n# Analyze with custom output location\ntestronaut analyze /usr/bin/git --output-dir ./git-tests --output-file git-analysis.json\n\n# Limit analysis depth\ntestronaut analyze /usr/bin/npm --max-depth 2\n</code></pre>"},{"location":"reference/cli/#generate","title":"generate","text":"<p>Generate a test plan from an analysis file.</p> <pre><code>testronaut generate [OPTIONS] ANALYSIS_PATH\n</code></pre>"},{"location":"reference/cli/#options_1","title":"Options","text":"Option Description <code>--output-dir PATH</code> Directory to store the test plan [default: current directory] <code>--output-file TEXT</code> Name of the output file [default: test_plan.json] <code>--test-scope [basic\\|comprehensive\\|exhaustive]</code> Scope of the test plan [default: comprehensive] <code>--test-cases INTEGER</code> Number of test cases to generate [default: 10] <code>--enhance</code> Use AI to enhance the test plan <code>--help</code> Show the command help message and exit"},{"location":"reference/cli/#examples_1","title":"Examples","text":"<pre><code># Generate a test plan from an analysis file\ntestronaut generate ./analysis.json\n\n# Generate a comprehensive test plan with more test cases\ntestronaut generate ./docker-analysis.json --test-scope exhaustive --test-cases 20\n\n# Generate a test plan with AI enhancements\ntestronaut generate ./npm-analysis.json --enhance\n</code></pre>"},{"location":"reference/cli/#execute","title":"execute","text":"<p>Execute a test plan against a CLI tool.</p> <pre><code>testronaut execute [OPTIONS] TEST_PLAN_PATH TOOL_PATH\n</code></pre>"},{"location":"reference/cli/#options_2","title":"Options","text":"Option Description <code>--output-dir PATH</code> Directory to store test results [default: current directory] <code>--output-file TEXT</code> Name of the output file [default: test_results.json] <code>--docker</code> Run tests in a Docker container <code>--image TEXT</code> Docker image to use for testing [default: ubuntu:latest] <code>--help</code> Show the command help message and exit"},{"location":"reference/cli/#examples_2","title":"Examples","text":"<pre><code># Execute a test plan\ntestronaut execute ./test_plan.json /usr/bin/docker\n\n# Execute tests in a Docker container\ntestronaut execute ./git-test-plan.json /usr/bin/git --docker\n\n# Execute with a specific Docker image\ntestronaut execute ./npm-test-plan.json /usr/bin/npm --docker --image node:16\n</code></pre>"},{"location":"reference/cli/#verify","title":"verify","text":"<p>Verify test results semantically using AI.</p> <pre><code>testronaut verify [OPTIONS] TEST_RESULTS_PATH\n</code></pre>"},{"location":"reference/cli/#options_3","title":"Options","text":"Option Description <code>--output-dir PATH</code> Directory to store verification results [default: current directory] <code>--output-file TEXT</code> Name of the output file [default: verification_results.json] <code>--detailed</code> Generate detailed verification reports <code>--help</code> Show the command help message and exit"},{"location":"reference/cli/#examples_3","title":"Examples","text":"<pre><code># Verify test results\ntestronaut verify ./test_results.json\n\n# Verify with detailed reports\ntestronaut verify ./docker-test-results.json --detailed\n</code></pre>"},{"location":"reference/cli/#report","title":"report","text":"<p>Generate reports from test results.</p> <pre><code>testronaut report [OPTIONS] TEST_RESULTS_PATH\n</code></pre>"},{"location":"reference/cli/#options_4","title":"Options","text":"Option Description <code>--output-dir PATH</code> Directory to store reports [default: current directory] <code>--format [html\\|json\\|md\\|pdf]</code> Report format [default: html] <code>--template PATH</code> Custom report template <code>--help</code> Show the command help message and exit"},{"location":"reference/cli/#examples_4","title":"Examples","text":"<pre><code># Generate an HTML report\ntestronaut report ./test_results.json\n\n# Generate a PDF report\ntestronaut report ./git-test-results.json --format pdf\n\n# Use a custom template\ntestronaut report ./npm-test-results.json --template ./my-template.html\n</code></pre>"},{"location":"reference/cli/#workflow","title":"workflow","text":"<p>Run a complete analysis, generation, execution, and reporting workflow.</p> <pre><code>testronaut workflow [OPTIONS] TOOL_PATH\n</code></pre>"},{"location":"reference/cli/#options_5","title":"Options","text":"Option Description <code>--output-dir PATH</code> Directory to store all outputs [default: current directory] <code>--test-scope [basic\\|comprehensive\\|exhaustive]</code> Scope of the test plan [default: comprehensive] <code>--docker</code> Run tests in a Docker container <code>--image TEXT</code> Docker image to use for testing [default: ubuntu:latest] <code>--report-format [html\\|json\\|md\\|pdf]</code> Report format [default: html] <code>--help</code> Show the command help message and exit"},{"location":"reference/cli/#examples_5","title":"Examples","text":"<pre><code># Run a complete workflow\ntestronaut workflow /usr/bin/docker\n\n# Run a comprehensive workflow with Docker\ntestronaut workflow /usr/bin/git --test-scope exhaustive --docker\n\n# Generate a PDF report\ntestronaut workflow /usr/bin/npm --report-format pdf\n</code></pre>"},{"location":"reference/configuration/","title":"Configuration","text":"<p>Testronaut can be configured through various methods to customize its behavior. This document details the available configuration options and how to set them.</p>"},{"location":"reference/configuration/#configuration-methods","title":"Configuration Methods","text":"<p>Testronaut supports multiple configuration methods, with the following precedence (highest to lowest):</p> <ol> <li>Command-line arguments</li> <li>Environment variables</li> <li>Configuration file</li> <li>Default values</li> </ol>"},{"location":"reference/configuration/#configuration-file","title":"Configuration File","text":"<p>Testronaut looks for a configuration file in the following locations:</p> <ol> <li>Path specified by the <code>--config</code> command-line option</li> <li><code>.testronaut.yml</code> or <code>.testronaut.yaml</code> in the current directory</li> <li><code>testronaut.yml</code> or <code>testronaut.yaml</code> in the current directory</li> <li><code>~/.config/testronaut/config.yml</code></li> </ol>"},{"location":"reference/configuration/#example-configuration-file","title":"Example Configuration File","text":"<pre><code># Basic configuration\noutput_dir: ./testronaut-output\nlog_level: INFO\nverbose: false\n\n# Analysis configuration\nanalyzer:\n  max_depth: 3\n  skip_subcommands: false\n  timeout: 30  # seconds\n  analyze_help_text: true\n\n# Test generation configuration\ngenerator:\n  test_scope: comprehensive  # basic, comprehensive, exhaustive\n  test_cases: 10\n  enhance: true\n  include_edge_cases: true\n  prioritize_commands: [\"init\", \"add\", \"commit\", \"push\"]\n\n# Test execution configuration\nexecutor:\n  use_docker: true\n  docker_image: ubuntu:latest\n  timeout: 60  # seconds\n  capture_stderr: true\n  capture_stdout: true\n  retry_count: 2\n\n# AI configuration\nai:\n  provider: openai  # openai, anthropic, local\n  model: gpt-4\n  temperature: 0.2\n  max_tokens: 1000\n  anthropic_model: claude-3-opus\n\n# Reporting configuration\nreporting:\n  format: html  # html, json, md, pdf\n  include_logs: true\n  include_screenshots: true\n  include_test_steps: true\n  include_command_output: true\n</code></pre>"},{"location":"reference/configuration/#environment-variables","title":"Environment Variables","text":"<p>All configuration options can be set through environment variables with the prefix <code>TESTRONAUT_</code>. Nested options use underscores to separate levels.</p> <p>Examples:</p> <pre><code># Basic configuration\nexport TESTRONAUT_OUTPUT_DIR=./testronaut-output\nexport TESTRONAUT_LOG_LEVEL=INFO\nexport TESTRONAUT_VERBOSE=false\n\n# Analysis configuration\nexport TESTRONAUT_ANALYZER_MAX_DEPTH=3\nexport TESTRONAUT_ANALYZER_SKIP_SUBCOMMANDS=false\n\n# Test generation configuration\nexport TESTRONAUT_GENERATOR_TEST_SCOPE=comprehensive\nexport TESTRONAUT_GENERATOR_TEST_CASES=10\n\n# AI configuration\nexport TESTRONAUT_AI_PROVIDER=openai\nexport TESTRONAUT_AI_MODEL=gpt-4\n</code></pre>"},{"location":"reference/configuration/#configuration-reference","title":"Configuration Reference","text":""},{"location":"reference/configuration/#basic-configuration","title":"Basic Configuration","text":"Option Description Default CLI Flag Environment Variable <code>output_dir</code> Directory for output files <code>./</code> <code>--output-dir</code> <code>TESTRONAUT_OUTPUT_DIR</code> <code>log_level</code> Log level (DEBUG, INFO, WARNING, ERROR, CRITICAL) <code>INFO</code> <code>--log-level</code> <code>TESTRONAUT_LOG_LEVEL</code> <code>verbose</code> Enable verbose output <code>false</code> <code>--verbose</code> <code>TESTRONAUT_VERBOSE</code> <code>quiet</code> Suppress non-error output <code>false</code> <code>--quiet</code> <code>TESTRONAUT_QUIET</code>"},{"location":"reference/configuration/#analyzer-configuration","title":"Analyzer Configuration","text":"Option Description Default CLI Flag Environment Variable <code>analyzer.max_depth</code> Maximum depth for subcommand analysis <code>3</code> <code>--max-depth</code> <code>TESTRONAUT_ANALYZER_MAX_DEPTH</code> <code>analyzer.skip_subcommands</code> Skip analyzing subcommands <code>false</code> <code>--skip-subcommands</code> <code>TESTRONAUT_ANALYZER_SKIP_SUBCOMMANDS</code> <code>analyzer.timeout</code> Timeout for command analysis in seconds <code>30</code> <code>--timeout</code> <code>TESTRONAUT_ANALYZER_TIMEOUT</code> <code>analyzer.analyze_help_text</code> Analyze command help text <code>true</code> <code>--skip-help-text</code> <code>TESTRONAUT_ANALYZER_ANALYZE_HELP_TEXT</code>"},{"location":"reference/configuration/#generator-configuration","title":"Generator Configuration","text":"Option Description Default CLI Flag Environment Variable <code>generator.test_scope</code> Scope of test generation (basic, comprehensive, exhaustive) <code>comprehensive</code> <code>--test-scope</code> <code>TESTRONAUT_GENERATOR_TEST_SCOPE</code> <code>generator.test_cases</code> Number of test cases to generate <code>10</code> <code>--test-cases</code> <code>TESTRONAUT_GENERATOR_TEST_CASES</code> <code>generator.enhance</code> Use AI to enhance test plans <code>false</code> <code>--enhance</code> <code>TESTRONAUT_GENERATOR_ENHANCE</code> <code>generator.include_edge_cases</code> Include edge cases in test plan <code>true</code> <code>--skip-edge-cases</code> <code>TESTRONAUT_GENERATOR_INCLUDE_EDGE_CASES</code> <code>generator.prioritize_commands</code> List of commands to prioritize in testing <code>[]</code> <code>--prioritize</code> <code>TESTRONAUT_GENERATOR_PRIORITIZE_COMMANDS</code>"},{"location":"reference/configuration/#executor-configuration","title":"Executor Configuration","text":"Option Description Default CLI Flag Environment Variable <code>executor.use_docker</code> Run tests in Docker container <code>false</code> <code>--docker</code> <code>TESTRONAUT_EXECUTOR_USE_DOCKER</code> <code>executor.docker_image</code> Docker image to use for testing <code>ubuntu:latest</code> <code>--image</code> <code>TESTRONAUT_EXECUTOR_DOCKER_IMAGE</code> <code>executor.timeout</code> Timeout for test execution in seconds <code>60</code> <code>--exec-timeout</code> <code>TESTRONAUT_EXECUTOR_TIMEOUT</code> <code>executor.capture_stderr</code> Capture standard error output <code>true</code> <code>--no-stderr</code> <code>TESTRONAUT_EXECUTOR_CAPTURE_STDERR</code> <code>executor.capture_stdout</code> Capture standard output <code>true</code> <code>--no-stdout</code> <code>TESTRONAUT_EXECUTOR_CAPTURE_STDOUT</code> <code>executor.retry_count</code> Number of retries for failed tests <code>0</code> <code>--retry</code> <code>TESTRONAUT_EXECUTOR_RETRY_COUNT</code>"},{"location":"reference/configuration/#ai-configuration","title":"AI Configuration","text":"Option Description Default CLI Flag Environment Variable <code>ai.provider</code> AI provider (openai, anthropic, local) <code>openai</code> <code>--ai-provider</code> <code>TESTRONAUT_AI_PROVIDER</code> <code>ai.model</code> Model name for OpenAI <code>gpt-4</code> <code>--ai-model</code> <code>TESTRONAUT_AI_MODEL</code> <code>ai.temperature</code> Temperature for AI generation <code>0.2</code> <code>--ai-temperature</code> <code>TESTRONAUT_AI_TEMPERATURE</code> <code>ai.max_tokens</code> Maximum tokens for AI generation <code>1000</code> <code>--ai-max-tokens</code> <code>TESTRONAUT_AI_MAX_TOKENS</code> <code>ai.anthropic_model</code> Model name for Anthropic <code>claude-3-opus</code> <code>--anthropic-model</code> <code>TESTRONAUT_AI_ANTHROPIC_MODEL</code>"},{"location":"reference/configuration/#reporting-configuration","title":"Reporting Configuration","text":"Option Description Default CLI Flag Environment Variable <code>reporting.format</code> Report format (html, json, md, pdf) <code>html</code> <code>--format</code> <code>TESTRONAUT_REPORTING_FORMAT</code> <code>reporting.include_logs</code> Include logs in report <code>true</code> <code>--no-logs</code> <code>TESTRONAUT_REPORTING_INCLUDE_LOGS</code> <code>reporting.include_screenshots</code> Include screenshots in report <code>true</code> <code>--no-screenshots</code> <code>TESTRONAUT_REPORTING_INCLUDE_SCREENSHOTS</code> <code>reporting.include_test_steps</code> Include test steps in report <code>true</code> <code>--no-steps</code> <code>TESTRONAUT_REPORTING_INCLUDE_TEST_STEPS</code> <code>reporting.include_command_output</code> Include command output in report <code>true</code> <code>--no-output</code> <code>TESTRONAUT_REPORTING_INCLUDE_COMMAND_OUTPUT</code>"}]}